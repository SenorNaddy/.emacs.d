#+STARTUP: content
#+OPTIONS: toc:4 h:4
#+TITLE: Emacs configuration

This document is the result of me wanting to test literate programming
and thinking that my emacs configuration was the perfect candidate. It
is directly inspired by [[http://sachachua.com/blog/2012/06/literate-programming-emacs-configuration-file/][a blog post]] by Sacha Chua and others.

* Defaults
  I like to use use the =M-x customize= functionality in emacs to
  configure at least the default configurations, but some things I
  have to do programmatically.

** color-theme
   The color theme that I like is called tomorrow-theme. I think the
   best package is the sanityinc one.

   #+BEGIN_SRC emacs-lisp
     (use-package color-theme-sanityinc-tomorrow
       :ensure t
       :commands color-theme-sanityinc-tomorrow-night)
   #+END_SRC

** Custom file
   When using =M-x customize=, or the tool bar to configure emacs the
   configuration is saved in [[file:init.el][init.el]]. I however feel that doing that
   is quite messy. I therefore set and load a different file to do
   that.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
   #+END_SRC

   If I am starting from new and I for some reason don't have the
   custom.el file I need to make sure that it exists by writing an
   empty buffer to the custom-file.

   #+BEGIN_SRC emacs-lisp
     (unless (file-exists-p custom-file)
       (with-temp-buffer
         (write-file custom-file)))
   #+END_SRC

   When we are sure that the custom.el file exists, it can be loaded.

   #+BEGIN_SRC emacs-lisp
     (load custom-file)
   #+END_SRC

** Default directory
   The default directory is usually set to =/=, but that is really
   annoying when most of the files that I want to access are within
   =~/=. To change that I change the default-directory value:

   #+BEGIN_SRC emacs-lisp
     (setq default-directory "~/")
   #+END_SRC

** font
   We only need to set the font if we are running in a
   window-system. If it is in a terminal it doesn't matter as we just
   use the font in the terminal.

   #+BEGIN_SRC emacs-lisp
     (when (window-system)
       (set-face-attribute 'default nil :font "fira-mono-14"))
   #+END_SRC

** frame size
   The default frame size is pretty small. It is better to calculate
   the size based on the size of the screen. At least the height. I
   used to set the width as well, but after getting only larger
   screens that is not a problem anymore.

   #+BEGIN_SRC emacs-lisp
     (when window-system
       (add-to-list 'default-frame-alist `(width . 100))
       (add-to-list 'default-frame-alist `(height . ,(/ (- (display-pixel-height) 50)
                                                        (frame-char-height)))))
   #+END_SRC

** Global keybindings
   There are just two global keybindings that I set. That is not
   specifically set when importing a new mode.

   #+BEGIN_SRC emacs-lisp
     (bind-keys*
      ("s-[" . backward-paragraph)
      ("s-]" . forward-paragraph)
      ("C-s" . isearch-forward-regexp)
      ("C-r" . isearch-backward-regexp))
   #+END_SRC

** locale
   We need to set the locale properly even though exec-path-from-shell
   should take care of some of that for us.

   #+BEGIN_SRC emacs-lisp
     (set-locale-environment "utf-8")
     (setenv "LANG" "en_US.UTF-8")
   #+END_SRC
** menu bar
   The menu bar is the usually at the top of the window, but in OS X
   it is at the top of the screen. On all other systems it just uses
   up space that can otherwise be used text.

   #+BEGIN_SRC emacs-lisp
     (unless (equal 'darwin system-type)
       (menu-bar-mode -1))
   #+END_SRC
** save-hook
   Things that should happen before saving

   #+BEGIN_SRC emacs-lisp
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+END_SRC
** yes-or-no-p
   I find =yes-or-no-p= really annoying. It is much better to call
   =y-or-n-p= instead. Then we can just press y or n instead of yes or
   no.

   #+BEGIN_SRC emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC
** ring-bell-function
   I don't like the bell. I don't understand what it is supposed to be
   telling me that I don't figure out by looking at the screen. To
   turn it completely off I set the =ring-bell-function= to =ignore=.

   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function 'ignore)
   #+END_SRC
** insert-directory-program
   On mac I have to install the coreutils and though I add gnu ls on
   the path, it seems it doesn't work correctly in emacs.

   #+BEGIN_SRC emacs-lisp
     (when (and (memq window-system '(mac ns))
                (file-exists-p "/usr/local/bin/gls"))
       (setq insert-directory-program "/usr/local/bin/gls"))
   #+END_SRC
* Functions
  In where I define my own functions and functionality.

  #+BEGIN_SRC emacs-lisp
    (defun ljos/back-to-indentation|beginning-of-line ()
      "Moves the cursor back to indentation or to the beginning of
    the line if it is already at the indentation. If it is at the
    beginning of the line it stays there."
      (interactive)
      (when (not (bolp))
        (let ((p (point)))
          (back-to-indentation)
          (when (= p (point))
            (beginning-of-line 1)))))

    (bind-key (kbd "C-a") 'ljos/back-to-indentation|beginning-of-line)
  #+END_SRC

* Global minor modes
** company
   auto-completion for emacs

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :init (global-company-mode))
   #+END_SRC
** exec-path-from-shell
   =exec-path-from-shell= is only needed when I am running OS X. Emacs
   on OS X doesn't set the path properly. This package helps with that.

   #+BEGIN_SRC emacs-lisp
     (when (memq window-system '(mac ns))
       (use-package exec-path-from-shell
         :ensure t
         :init
         (progn
           (add-to-list 'exec-path-from-shell-variables "DOKTORGRAD")
           (exec-path-from-shell-initialize))))
   #+END_SRC
** highlight-symbol
   highlight-symbol makes it easier to discover the uses of symbols in
   source code.

   #+BEGIN_SRC emacs-lisp
     (use-package highlight-symbol
       :ensure t
       :commands highlight-symbol-mode
       :config
       (progn
         (setq highlight-symbol-idle-delay 0.2)
         (add-hook 'highlight-symbol-mode-hook
                   (function
                    (lambda () (highlight-symbol-nav-mode +1))))))
   #+END_SRC

   =highlight-symbol-nav-mode= makes it easier to navigate between the
   symbols.

** hungry-delete-mode
   =hungry-delete-mode= is a "free feature". It deletes all
   concecutive white space in the direction of deletion.

   #+BEGIN_SRC emacs-lisp
     (use-package hungry-delete
       :ensure t
       :init (global-hungry-delete-mode +1))
   #+END_SRC

** ido-mode
   =ido-mode= is built into emacs, but there are some configurations
   that I like. First, there is the =flx-ido= mode. It provides better
   fuzzy matching. Fuzzy matching is nice because it helps when I make
   spelling errors or don't want to write the whole file name.

   #+BEGIN_SRC emacs-lisp
     (use-package flx-ido
       :ensure t
       :commands flx-ido-mode)
   #+END_SRC

   ido usually displays the matches it finds horizontally, but it is
   much nicer to have it vertically.

   #+BEGIN_SRC emacs-lisp
     (use-package ido-vertical-mode
       :ensure t
       :commands ido-vertical-mode)
   #+END_SRC

   Ido needs some configurations to work the way I want, but with that
   set up it is really nice to have.

   #+BEGIN_SRC emacs-lisp
     (use-package ido
       :init (ido-mode +1)
       :bind ("C-x C-f" . ido-find-file)
       :config
       (progn
         (flx-ido-mode +1)
         (ido-vertical-mode +1)
         (setq ido-auto-merge-work-directories-length nil
               ido-create-new-buffer 'always
               ido-enable-flex-matching t
               ido-enable-dot-prefix t
               ido-handle-dubplicate-virtual-buffers 2
               ido-max-prospects 10
               ido-everywhere t
               ido-use-filename-at-point 'guess
               ido-use-virtual-buffers t)
         (use-package ido-ubiquitous
           :ensure t)
         (add-to-list 'ido-ignore-buffers ".*-autoloads.el")))
   #+END_SRC

** ispell
   Ispell provides spelling for a large amount of languages and is
   nice when I write text and need to check a word or two.

   #+BEGIN_SRC emacs-lisp
     (use-package ispell)
   #+END_SRC

** perspective
   Perspective mode allows different projects to save window settings
   and keeps buffers between projects seperate.

   #+BEGIN_SRC emacs-lisp
     (use-package perspective
       :ensure t
       :commands persp-mode)
   #+END_SRC
** projectile
   =projectile= is a project integeraction library for emacs. It makes
   it easier to navigate and handle project specific things.

   #+BEGIN_SRC emacs-lisp
     (use-package persp-projectile
       :ensure t
       :commands persp-projectile)

     (use-package projectile
       :ensure t
       :init (projectile-global-mode)
       :bind ("s-p" . projectile-command-map)
       :config (progn
                 (setq projectile-switch-project-action 'projectile-dired)
                 (persp-mode)
                 (require 'persp-projectile)))
   #+END_SRC

** saveplace
   =saveplace= records the place the cursor was in when we last
   visited a file. It also remembers the place when we close Emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package saveplace)
   #+END_SRC
** smart-mode-line
   I used to have a lot of configurations for the mode-line, but I
   have decided that it is just better to use =smart-mode-line=
   instead.

   #+BEGIN_SRC emacs-lisp
     (use-package smart-mode-line
       :ensure t
       :init (sml/setup)
       :config
       (progn
         (setq sml/cv-mode-show-backend t)
         (sml/apply-theme 'respectful nil 't)))
   #+END_SRC
** smex
   =smex= makes it so that I can use ido-mode for =M-x= as well.

   #+BEGIN_SRC emacs-lisp
     (use-package smex
       :ensure t
       :bind (("M-x" . smex)
              ("M-X" . smex-major-mode-commands)))
   #+END_SRC

** uniquify
   Creates unique buffer names. Makes it easier to navigate =C-x b=.

   #+BEGIN_SRC emacs-lisp
     (use-package uniquify)
   #+END_SRC

** visual-regexp
   =visual-regexp= visualizes the regexp-replace. It makes it much
   easier to see what is being matched and what is not and how it is
   transformed.

   #+BEGIN_SRC emacs-lisp
     (use-package visual-regexp
       :ensure t
       :bind (("C-c q" . vr/query-replace)
              ("C-c r" . vr/replace)))
   #+END_SRC
** window-number
   window-number adds a number to each window in the frame and allows
   me to jump to that number by calling a simple command.

   #+BEGIN_SRC emacs-lisp
     (use-package window-number
       :load-path "site-lisp/"
       :init (window-number-mode))
   #+END_SRC

* Major modes
  I use emacs for programming in many languages.

** clojure
   =clojure= is a lisp dialect, but it needs many of its own
   configurations.

   =cider= is a mode to talk to a clojure repl. It handles
   communications and debugging/tracing etc. stuff.

   #+BEGIN_SRC emacs-lisp
     (use-package cider
       :ensure t
       :commands (cider-jack-in cider)
       :config
       (progn
         (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
         (add-hook 'cider-repl-mode-hook 'enable-paredit-mode)
         (setq nrepl-hide-special-buffers t
               cider-stacktrace-fill-column t
               cider-repl-print-length 100)))
   #+END_SRC

   =clojure-mode= is the mode that lets us program in clojure.

   #+BEGIN_SRC emacs-lisp
     (use-package clojure-mode
       :ensure t
       :mode (("\\.clj[sx]?$" . clojure-mode)
              ("\\.edn$" . clojure-mode))
       :config
       (progn
         (add-hook 'clojure-mode-hook 'subword-mode)
         (add-hook 'clojure-mode-hook 'enable-paredit-mode)))
   #+END_SRC

** ess-mode
   "emacs speaks statistics" is a very big mode, but it contains the R
   mode that I use.

   #+BEGIN_SRC emacs-lisp
     (use-package ess
       :ensure t
       :init
       (progn
         (use-package ess-site
           :commands R
           :mode ("\\.R$" . R-mode)
           :config
           (progn
             (add-hook 'R-mode-hook 'subword-mode)))
        (org-babel-do-load-languages
         'org-babel-load-languages
         '((R . t)))))
   #+END_SRC
** lisp
   =lisp-mode= is the basis for programming in lisp for several lisp
   dialects.

   I only use paredit with the lisps. It becomes to much of a hassle
   to try and make it work with other modes that are not so
   parenthesis heavy.

   #+BEGIN_SRC emacs-lisp
     (use-package paredit
       :ensure t
       :commands (enable-paredit-mode
                  paredit-mode
                  ljos/conditionally-enable-paredit-mode)
       :config
       (defun ljos/conditionally-enable-paredit-mode ()
         "Enable paredit-mode during eval-expression"
         (when (eq this-command 'eval-expression)
           (paredit-mode +1))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package slime
       :commands slime
       :config
       (progn
         (setq inferior-lisp-program "sbcl"
               slime-contribs '(slime-fancy))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package elisp-slime-nav
       :ensure t
       :commands elisp-slime-nav-mode)
   #+END_SRC

   =lisp-mode= contains =emacs-lisp-mode= so we need to load that to
   use emacs-lisp-mode. This is also where we can set the
   minibuffer-setup-hook so that we get paredit in the minibuffer when
   we are evaluating expressions.

   #+BEGIN_SRC emacs-lisp
     (use-package lisp-mode
       :bind (([C-s-268632091] . backward-sexp)
              ([C-s-268632093] . forward-sexp))
       :config (progn
                 (add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode)
                 (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
                 (add-hook 'emacs-lisp-mode-hook 'elisp-slime-nav-mode)
                 (add-hook 'ielm-mode-hook 'elisp-slime-nav-mode)
                 (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
                 (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
                 (add-hook 'minibuffer-setup-hook 'ljos/conditionally-enable-paredit-mode)))
   #+END_SRC

** lua-mode
   =lua-mode= lets me read lua-files. I don't really program in lua,
   but I sometimes come over files that I need to read.

   #+BEGIN_SRC emacs-lisp
     (use-package lua-mode
       :ensure t
       :mode ("\\.lua$" . lua-mode))
   #+END_SRC
** magit
   magit mode makes it so much easier to administer git repositories
   from emacs. As I have also just briefly started to use git-annex I
   am also using magit-annex.

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t
       :bind ("C-x g" . magit-status))
   #+END_SRC

** org-mode
   I used to have a very big org-mode configuration, but I decided to
   start over and see what I really use.

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :ensure org-plus-contrib
       :mode ("\\.org$" . org-mode)
       :config
       (progn
         (use-package org-magit
           :load-path "site-lisp/org-magit")
         (org-babel-do-load-languages
          'org-babel-load-languages
          '((sh . t)
            (awk . t)))
         (setq org-completion-use-ido t
               org-export-with-section-numbers nil
               org-export-with-toc nil
               org-src-fontify-natively t
               org-src-window-setup 'current-window
               org-startup-folded 'showall
               org-use-speed-commands t)
         (add-hook 'org-mode-hook (function
                                   (lambda () (auto-fill-mode +1))))))
   #+END_SRC

*** ox-latex
    ox-latex is part of org mode and provides export to latex from
    org-mode.

    #+BEGIN_SRC emacs-lisp
      (use-package ox-latex
        :ensure org-plus-contrib
        :defer t
        :config
        (progn
          (setq org-latex-pdf-process '("latexmk -gg -pdf -bibtex %f"))

          (unless (boundp 'org-latex-packages-alist)
            (setq org-latex-packages-alist nil))

          (add-to-list 'org-latex-packages-alist '("" "microtype"))
          (add-to-list 'org-latex-packages-alist '("l2tabu" "nag"))
          (add-to-list 'org-latex-packages-alist '("round" "natbib"))
          (add-to-list 'org-latex-packages-alist '("" "lmodern") 't)))
    #+END_SRC
*** org-babel
   I use org-babel a lot in my research, but I like to use bash, and
   not just plain sh.

   #+BEGIN_SRC emacs-lisp
     (use-package ob-sh
       :defer t
       :init
       (progn
         (setq org-babel-sh-command "bash")
         (add-to-list 'org-babel-default-header-args:sh
                      '(:shebang . "#!/usr/bin/env bash"))))
   #+END_SRC

** prolog
   Prolog is fun.

   #+BEGIN_SRC emacs-lisp
     (use-package prolog
       :ensure t
       :mode ("\\.pl" . prolog-mode))
   #+END_SRC
** python
   #+BEGIN_SRC emacs-lisp
     (use-package elpy
       :ensure t
       :init (elpy-enable))
   #+END_SRC
** simple
   =simple= is the package that contains =prog-mode=. Most programming
   modes inherit from this mode. We can take advantage of that and add
   some minor modes to all programming modes.

   #+BEGIN_SRC emacs-lisp
     (use-package simple
       :config
       (progn
         (add-hook 'prog-mode-hook
                   (function
                    (lambda () (highlight-symbol-mode +1))))))
   #+END_SRC

** sparql-mode
   =sparql-mode= is a mode for writing sparql-queries in. It also
   supports org-babel.

   #+BEGIN_SRC emacs-lisp
     (use-package sparql-mode
       :load-path "site-lisp/sparql-mode"
       :mode "\\.sparql$"
       :config
       (progn
         (setq sparql-default-base-url "http://live.dbpedia.org/sparql")))
   #+END_SRC
